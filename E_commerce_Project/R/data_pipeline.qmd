---
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r}
library(readr)
library(RSQLite)
library(tibble) 
library(dplyr) 
library(lubridate)
library(ggplot2)
library(DBI)
library(tidyr)
```

## Task 1.1 - 


## Task 1.2 - SQL Database Schema Creation 


```{r}

setwd("/cloud/project/")

#connect to the SQLite database
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")


dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS CUSTOMERS
                (   
                    customer_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    first_name VARCHAR(255) NOT NULL,
                    last_name VARCHAR(255),
                    username VARCHAR(255),
                    gender TEXT,
                    date_of_birth DATE NOT NULL,
                    email VARCHAR(255) UNIQUE,
                    phone VARCHAR(20) UNIQUE,
                    street_name VARCHAR(255),
                    city VARCHAR(255),
                    country VARCHAR(255),
                    zip_code VARCHAR(20),
                    account_created_date TIMESTAMP,
                    premium_subscription INTEGER
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCT_CATEGORY
                (
                    category_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    cat_name VARCHAR(255)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SUPPLIERS
                (
                    supplier_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    supplier_name VARCHAR(255),
                    supplier_address VARCHAR(500),
                    supplier_phone VARCHAR(20),
                    supplier_email VARCHAR(255) UNIQUE
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCTS
                (
                    product_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    product_name VARCHAR(255),
                    price REAL,
                    stock_quantity INTEGER NOT NULL,
                    category_id VARCHAR(255) NOT NULL,
                    supplier_id VARCHAR(255) NOT NULL,
                    FOREIGN KEY(category_id) 
                    REFERENCES PRODUCT_CATEGORY(category_id),
                    FOREIGN KEY(supplier_id) REFERENCES SUPPLIERS(supplier_id)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS GIFT_CARD
                (
                gift_card_id VARCHAR(50) NOT NULL PRIMARY KEY,
                gift_card_code VARCHAR(50),
                detail INTEGER,
                status VARCHAR(50)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS ORDERS
                (
                    order_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    customer_id VARCHAR(255),
                    product_id VARCHAR(255),
                    gift_card_id VARCHAR(255), 
                    payment_method TEXT,
                    quantity INTEGER,
                    order_timestamp TIMESTAMP,
                    payment_timestamp TIMESTAMP,
                    order_status VARCHAR(50) NOT NULL,
                    shipment_id VARCHAR(255),
                    FOREIGN KEY(customer_id) REFERENCES CUSTOMERS(customer_id),
                    FOREIGN KEY(product_id) REFERENCES PRODUCTS(product_id),
                    FOREIGN KEY(shipment_id) REFERENCES SHIPMENT(shipment_id), 
                    FOREIGN KEY(gift_card_id) REFERENCES GIFT_CARD(gift_card_id) 
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SHIPMENT
                (
                shipment_id VARCHAR(255) NOT NULL PRIMARY KEY,
                dispatch_timestamp DATETIME,
                delivered_timestamp DATETIME,
                status VARCHAR(50) NOT NULL
                );"
          )

#Check if the tables are created

dbGetQuery(my_connection, 
    sprintf("SELECT name FROM sqlite_master WHERE type='table';")
  )


# dbDisconnect(my_connection)


```

#Generate Data

```{r}
## Find all files matching the pattern
customer_files <- list.files(path = "datasets"
                             ,pattern = "CUSTOMERS.*\\.csv$",full.names = TRUE )
category_files <- list.files(path = "datasets"
                             ,pattern = "CATEGORY.*\\.csv$",full.names = TRUE )
gift_card_files <- list.files(path = "datasets"
                              ,pattern = "GIFT_CARDS.*\\.csv$",full.names = TRUE )
suppliers_files <- list.files(path = "datasets"
                              ,pattern = "SUPPLIERS.*\\.csv$",full.names = TRUE )
products_files <- list.files(path = "datasets"
                             ,pattern = "PRODUCTS.*\\.csv$",full.names = TRUE )

customers_df <- readr::read_csv(customer_files[1])
gift_card_df <- readr::read_csv(gift_card_files[1])
suppliers_df <- readr::read_csv(suppliers_files[1])
category_df <- readr::read_csv(category_files[1]) 
products_df <- readr::read_csv(products_files[1])



#Sample Customers

sample_size <- floor(0.2 * nrow(products_df))
sampled_product_ids <- sample(products_df$product_id
                              , size = sample_size, replace = FALSE)
sampled_products_df <- products_df[products_df$product_id 
                                   %in% sampled_product_ids, ]


#Sample Products

sample_size <- floor(0.2 * nrow(customers_df))
sampled_customer_ids <- sample(customers_df$customer_id
                               , size = sample_size, replace = FALSE)
sampled_customers_df <- customers_df[customers_df$customer_id 
                                     %in% sampled_customer_ids, ]


generate_orders_data <- function(n = 1000) {
  set.seed(123) 
  
  orders_df <- tibble(
    order_id = sprintf("%s-%04d", "ORD", 1:n),
    customer_id = sample(sampled_customers_df$customer_id, n, replace = TRUE),
    product_id = sample(sampled_products_df$product_id, n, replace = TRUE),
    gift_card_id = sample(c(NA, gift_card_df$gift_card_id), n, replace = TRUE)
    , # Assuming gift cards are used as discounts
    payment_method = sample(c("Credit Card", "Debit Card"
                              , "PayPal", "Gift Card"), n, replace = TRUE),
    quantity = sample(1:5, n, replace = TRUE),
    order_timestamp = sample(seq(as.POSIXct('2024/02/01')
                                 , as.POSIXct('2024/02/29'), by="day")
                             , n, replace = TRUE),
    payment_timestamp = order_timestamp + hours(sample(1:72, n, replace = TRUE)),
    order_status = sample(c("Processing", "Shipped", "Delivered"
                            , "Cancelled","Pending Payment","Out for Delivery")
                          , n, replace = TRUE),
  )
  
  # Augment the orders data frame with supplier_id using left_join
  orders_df <- orders_df %>%
    left_join(sampled_products_df %>% select(product_id, supplier_id)
              , by = "product_id") %>%
    select(order_id, customer_id, product_id, gift_card_id, payment_method
           , quantity, order_timestamp, payment_timestamp
           , order_status, supplier_id)
  
  return(orders_df)
}

# Generate orders data
orders_df <- generate_orders_data(n = 1000)

generate_shipment_ids <- function(df) {
  # Create a unique identifier for each group
  df <- df %>% 
    mutate(date_only = as.Date(order_timestamp)) %>% 
    group_by(customer_id, supplier_id, date_only) %>%
    mutate(shipment_group_id = cur_group_id()) %>%
    ungroup() %>%
    mutate(shipment_id = sprintf("SHIP%05d", shipment_group_id)) %>%
    select(-shipment_group_id, -date_only) # Clean up the extra columns
  
  df
}

# Apply the function to your data frame
orders_df <- generate_shipment_ids(orders_df)

# Optional: Adjusting for logical consistency (e.g., 
# cancelled orders should not have a shipment_id)
  orders_df <- orders_df %>%
    mutate(shipment_id = if_else(order_status %in% 
                                   c("Cancelled","Pending Payment")
                                 , NA_character_,as.character(shipment_id)),
           payment_method = if_else(order_status == "Pending Payment"
                                    ,NA_character_,payment_method),
           gift_card_id = if_else(payment_method == "Gift Card",gift_card_id,NA_character_)) %>%
    mutate(supplier_id = NULL)

used_gift_cards <- unique(na.omit(orders_df$gift_card_id))
gift_card_df$status[gift_card_df$gift_card_id %in% used_gift_cards] <- 'USED'
```


```{r}
#Shipment Table
  
  shipment_df <- orders_df %>%
    mutate(
      # Dispatch date could be the same as the order date or a day after
      dispatch_timestamp = order_timestamp + days(sample(0:1
                                                      , n(), replace = TRUE)),
      
      # Delivered date should be after the dispatch date; 
      #here I assume delivery takes between 2 to 5 days
      delivered_timestamp = dispatch_timestamp + days(sample(2:14
                                                    , n(), replace = TRUE)),
      
      # Randomly assign a delivery status
      status = if_else(order_status == "Processing","Ready for Dispatch"
              ,if_else(order_status == "Shipped","In Transit"
              ,if_else(order_status == "Out for Delivery",order_status
              ,if_else(order_status == "Delivered",order_status,"NA"))))
    ) %>%
    # Select only the relevant columns for the shipment table
    select(shipment_id, dispatch_timestamp, delivered_timestamp, status) %>%
    # Remove duplicate rows to ensure unique shipments
    distinct() 

  shipment_df <- na.omit(shipment_df)
  
  
  shipment_df <- shipment_df %>%
    mutate(
      # Assign NA to dispatch_timestamp if status is 'Ready for Dispatch'
      dispatch_timestamp = if_else(status == "Ready for Dispatch"
                                   , NA_Date_, dispatch_timestamp),
      delivered_timestamp = if_else(status == "Ready for Dispatch"
                                    , NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "In Transit",
                                  Sys.Date() - days(sample(1:14, 1)), 
                                  dispatch_timestamp),
      delivered_timestamp = if_else(status == "In Transit"
                                    , NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "Out for Delivery"
                                   , Sys.Date() - days(sample(1:14, 1))
                                   , dispatch_timestamp),
      delivered_timestamp = if_else(status == "Out for Delivery"
                                    , NA_Date_, delivered_timestamp)
    )
  
write_csv(orders_df,"datasets/ORDERS.csv")

write_csv(shipment_df,"datasets/SHIPMENTS.csv")


```

Data Validation and Ingestion

```{r}
check_column_match <- function(df, expected_cols) {
  # Check if all expected columns are present in the dataframe
  missing_cols <- setdiff(expected_cols, names(df))

  if (length(missing_cols) > 0) {
    stop(sprintf("The dataframe is missing these columns expected by the SQL table: %s", 
                 paste(missing_cols, collapse = ", ")))
  }
  
  return(TRUE)
}
```



1.CUSTOMERS

```{r}
ingest_customer_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")
  # Data validation
  
  expected_cols <- c("customer_id", "first_name", "last_name", "username", 
                     "gender", "date_of_birth", "email", "phone", "street_name", 
                     "city", "country", "zip_code", "account_created_date", 
                     "premium_subscription")

  if (!check_column_match(df, expected_cols)) return(FALSE)  
  
  #email check
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
                       , df$email)
  df <- df[valid_email, ]
  
  #gender check
  valid_genders <- c("Male", "Female", "Other")
  df <- df[df$gender %in% valid_genders, ]
  

  # Data type checks (adjust according to your data frame)
  df$date_of_birth <- as.Date(df$date_of_birth,format = "%d/%m/%y")
  df$account_created_date <- as.Date(df$account_created_date,format = "%d/%m/%y")
  df$premium_subscription <- as.integer(df$premium_subscription)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("customer_id", "first_name", "date_of_birth")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    
      #Check for duplicate records based on the primary key
   existing_ids <- dbGetQuery(my_connection, 
  sprintf("SELECT customer_id FROM CUSTOMERS WHERE customer_id = '%s'"
          ,   df$customer_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for customer_id: %s\n"
                  , df$customer_id[i]))
      next
    }
     
    insert_query <- sprintf("INSERT INTO CUSTOMERS (customer_id, first_name
    , last_name, username, gender, date_of_birth, email, phone, street_name
    , city, country, zip_code, account_created_date, premium_subscription)
    VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s'
    , '%s', '%s', %d)",
    df$customer_id[i], df$first_name[i], df$last_name[i], df$username[i]
    , df$gender[i], df$date_of_birth[i],df$email[i], df$phone[i]
    , df$street_name[i], df$city[i], df$country[i], df$zip_code[i]
    , df$account_created_date[i], df$premium_subscription[i])
    tryCatch({
    dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
      }
    
      # Close the database connection
    dbDisconnect(my_connection)
}

for(file in customer_files) {
  df <- readr::read_csv(file)
  ingest_customer_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM CUSTOMERS;")
```


2. PRODUCT_CATEGORY 

```{r}
ingest_product_category <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")
  
  expected_cols <- c("category_id", "cat_name")
  if (!check_column_match(df, expected_cols)) return(FALSE)  

  # Check for null values in NOT NULL columns
  required_columns <- c("category_id", "cat_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT category_id 
            FROM PRODUCT_CATEGORY WHERE category_id = '%s'", df$category_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for category_id: %s\n"
                  , df$category_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO PRODUCT_CATEGORY 
                            (category_id, cat_name) VALUES ('%s', '%s')",
                            df$category_id[i], df$cat_name[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
  
    dbDisconnect(my_connection)

}

for(file in category_files) {
  
  df <- readr::read_csv(file)
  ingest_product_category(df)
}

```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                    , "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCT_CATEGORY;")
```


SUPPLIERS

```{r}
ingest_suppliers <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite()
                                      , "database/ecommerce_database_v1.db")
  
  expected_cols <- c("supplier_id", "supplier_name", "supplier_address", 
                     "supplier_phone", "supplier_email")
  if (!check_column_match(df, expected_cols)) return(FALSE)  
  

  # Email format validation
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
                       , df$supplier_email)
  df <- df[valid_email, ]
  
  # Check for null values in NOT NULL columns
  required_columns <- c("supplier_id", "supplier_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_supplier_ids <- dbGetQuery(my_connection, sprintf("SELECT 
      supplier_id FROM SUPPLIERS WHERE supplier_id = '%s'", df$supplier_id[i]))
    if(nrow(existing_supplier_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for supplier_id: %s\n"
                  , df$supplier_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SUPPLIERS (supplier_id, supplier_name
      , supplier_address, supplier_phone, supplier_email) 
      VALUES ('%s', '%s', '%s', '%s', '%s')",
                            df$supplier_id[i], df$supplier_name[i], 
      df$supplier_address[i], df$supplier_phone[i], df$supplier_email[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
    
  }
    dbDisconnect(my_connection)

}

for(file in suppliers_files) {
  
  df <- readr::read_csv(file)
  ingest_suppliers(df)
  
}

```

GIFT CARDS

```{r}

ingest_gift_card_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  expected_cols <- c("gift_card_id", "gift_card_code", "detail", "status")
  if (!check_column_match(df, expected_cols)) return(FALSE)  
  
  # Validate 'gift_card_id' and 'gift_card_code' for null values
  required_columns <- c("gift_card_id", "gift_card_code", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Ensure 'detail' is an integer
  df$detail <- as.numeric(df$detail)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT gift_card_id FROM GIFT_CARD WHERE gift_card_id = '%s'", df$gift_card_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for gift_card_id: %s\n", df$gift_card_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO GIFT_CARD (gift_card_id, gift_card_code, detail, status) VALUES ('%s', '%s', %f, '%s')",
                            df$gift_card_id[i], df$gift_card_code[i], df$detail[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in gift_card_files) {
  
  df <- readr::read_csv(file)
  ingest_gift_card_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM GIFT_CARD;")
```

PRODUCTS

```{r}
ingest_products <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  
  expected_cols <- c("product_id", "product_name", "price", 
                     "stock_quantity", "category_id", "supplier_id")
  if (!check_column_match(df, expected_cols)) return(FALSE)  
  
  # Data type checks
  df$stock_quantity <- as.integer(df$stock_quantity)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("product_id", "stock_quantity", "category_id", "supplier_id")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key and foreign key constraints
    existing_product_ids <- dbGetQuery(my_connection, sprintf("SELECT product_id FROM PRODUCTS WHERE product_id = '%s'", df$product_id[i]))
    if(nrow(existing_product_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for product_id: %s\n", df$product_id[i]))
      next
    }
    
    # Construct and execute the insertion query
    insert_query <- sprintf("INSERT INTO PRODUCTS (product_id, product_name, price, stock_quantity, category_id, supplier_id) VALUES ('%s', '%s', %f, %d, '%s', '%s')",
                            df$product_id[i], df$product_name[i], df$price[i], df$stock_quantity[i], df$category_id[i], df$supplier_id[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in products_files) {
  
  df <- readr::read_csv(file)
  ingest_products(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCTS;")
```


ORDER



```{r}
ingest_orders <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  
  expected_cols <- c("order_id", "customer_id", "product_id", "shipment_id", 
                     "gift_card_id", "payment_method", "quantity", 
                     "order_timestamp", "payment_timestamp", "order_status")
  if (!check_column_match(df, expected_cols)) return(FALSE)  
  
  # Essential columns for validation
  required_columns <- c("order_id", "order_status", "quantity")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)) {
    # Check for duplicate order_id
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT order_id FROM ORDERS WHERE order_id = '%s'", df$order_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for order_id: %s\n", df$order_id[i]))
      next
    }

    # Data validation for quantity
    if(!is.numeric(df$quantity[i]) || df$quantity[i] <= 0) {
      cat(sprintf("Skipping entry due to invalid quantity for order_id: %s\n", df$order_id[i]))
      next
    }

    # Insert validated data into the database
    insert_query <- sprintf("INSERT INTO ORDERS (order_id, customer_id, product_id, shipment_id, gift_card_id, payment_method, quantity, order_timestamp, payment_timestamp, order_status) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')",
                            df$order_id[i], df$customer_id[i], df$product_id[i], df$shipment_id[i], df$gift_card_id[i], df$payment_method[i], df$quantity[i], df$order_timestamp[i], df$payment_timestamp[i], df$order_status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}


# Assume orders_df is your DataFrame containing orders data
ingest_orders(orders_df)


```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM ORDERS;")
```


SHIPMENTS



```{r}
ingest_shipment_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  
  expected_cols <- c("shipment_id", "dispatch_timestamp", 
                     "delivered_timestamp", "status")
  if (!check_column_match(df, expected_cols)) return(FALSE)  
  
  # Validate 'shipment_id' and 'status' for null values
  required_columns <- c("shipment_id", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Convert timestamps to appropriate format
 #df$dispatch_timestamp <- ifelse(is.na(df$dispatch_timestamp), "", df$dispatch_timestamp)
  #df$delivered_timestamp <- ifelse(is.na(df$delivered_timestamp), "", df$delivered_timestamp)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT shipment_id FROM SHIPMENT WHERE shipment_id = '%s'", df$shipment_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for shipment_id: %s\n", df$shipment_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SHIPMENT (shipment_id, dispatch_timestamp, delivered_timestamp, status) VALUES ('%s', '%s', '%s', '%s')",
                            df$shipment_id[i], df$dispatch_timestamp[i], df$delivered_timestamp[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

ingest_shipment_data(shipment_df)
```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM SHIPMENT;")
```

Foreign Key Check
ORDERS
customer_id check
```{r}

dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.customer_id as customer_id,
              c.customer_id as customer_id,
              first_name ||' '|| last_name as customer_name
           FROM ORDERS as o
           LEFT JOIN CUSTOMERS as c ON c.customer_id = o.customer_id
           ;")
```

product_id check

```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.product_id as product_id,
              p.product_id as product_id,
              product_name as product_name
           FROM ORDERS as o
           LEFT JOIN PRODUCTS as p ON o.product_id = p.product_id
           WHERE p.product_id is NULL
           ;")
```

gift_card_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.gift_card_id as gif_card_id,
              g.gift_card_id,
              gift_card_code
           FROM ORDERS as o
           LEFT JOIN GIFT_CARD as g ON g.gift_card_id = o.gift_card_id
           ;")
```

shipment_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.shipment_id as x,
              s.shipment_id
           FROM ORDERS as o
           LEFT JOIN SHIPMENT as s ON s.shipment_id = o.shipment_id
           ORDER BY o.shipment_id
           ;")
```

PRODUCTS

```{r}
dbExecute(my_connection,"DELETE FROM PRODUCTS
WHERE supplier_id IN ('01HQZS3CJJMZ8VE8FSFV12394Q', '01HQZS3CJSA14X7CFXR9GN7HJJ', '01HQZS3CK7TNQY984CRWZ2YWYH', '01HQZS3CP6J1E2W3K754ED8TSV', '01HQZS3CWAANK3HMDV70KFNRTE', '01HQZS3CZ808EDV2QSZ7EC6RGQ', '01HQZS3D2JCXJ0GKKPY6JT5RMM');
")
```


supplier_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.supplier_id,
              s.supplier_id as a,
              s.supplier_name
           FROM PRODUCTS as p
           LEFT JOIN SUPPLIERS as s ON p.supplier_id = s.supplier_id
           where s.supplier_id is NULL
           ORDER BY p.supplier_id
           ;")
```

category_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.category_id,
              c.category_id as c,
              cat_name
           FROM PRODUCTS as p
           LEFT JOIN PRODUCT_CATEGORY as c ON c.category_id = p.category_id
           ORDER BY p.category_id
           ;")
```


SQL version

1. Top 10 Products - Overall (Quantity)

This code functions as an insightful sales analyst allowing to identify the 
top-performing products. It begins by compiling data about the products, their 
respective categories, and details of  fulfilled orders. Subsequently, it 
calculates the total revenue generated for each product. The code then 
systematically groups products by category and ranks them according to their 
sales performance. Lastly, it presents the top three best-selling products 
within each category, providing valuable insights into customer preferences.

In the bar chart, products are ranked by total sales (highest to lowest),
presenting the top 10.Each bar visually represents a product, and the length of 
the bar indicates how much revenue that product has brought in. 

```{r}

# Define the SQL query
query_1 <- dbGetQuery(my_connection,
           "SELECT 
              ORDERS.product_id,
              product_name,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY ORDERS.product_id,product_name
           ORDER BY total_purchase desc
           LIMIT 10
           ;")

ggplot(query_1, aes(x = reorder(product_name, total_purchase), y = total_purchase, fill = total_purchase)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 10 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

2. Top 5 Categories (Quantity)

This code wants to find out which product categories are most popular with the
customers. It examines orders marked as "shipped" or "delivered," and  connects
them to the products purchased and their respective categories. Then, for each 
category, it counts the total number of individual product items sold. Finally, 
it ranks the categories by this total (highest to lowest) and presents the top 
5 in the visually appealing bar chart to display the results. Each bar 
represents a product category, and the length of the bar shows how many items 
were purchased from that category.

```{r}

# SQL query to fetch top 5 categories by quantity.
query_2 <- dbGetQuery(my_connection,
           "SELECT 
              cat_name as category,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           JOIN PRODUCT_CATEGORY ON PRODUCTS.category_id = PRODUCT_CATEGORY.category_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY cat_name
           ORDER by total_purchase desc
           LIMIT 5
           ;")

ggplot(query_2, aes(x = reorder(category, total_purchase), y = total_purchase, fill = category)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 5 Categories by Quantity",
       x = "Category",
       y = "Quantity Sold") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))

```

3. Top 3 Products across categories (Total Amount)

This code is designed to find the best-selling products within each category. 
It first gathers product information, categories, and calculates the total 
revenue generated by each product from completed orders. The code then groups 
products by category and ranks them based on sales within their category. 
Finally, it reveals the top 3 best-selling products from each category and 
creates a bar chart to visualize this information. The chart displays the 
product names, sales amounts, and uses color to distinguish different 
categories, making it easy to see top performers.

```{r}
query_3 <- dbGetQuery(my_connection,
           "WITH product AS (
              SELECT
                p.product_id,
                pc.cat_name,
                p.product_name
              FROM PRODUCTS as p
              JOIN PRODUCT_CATEGORY as pc ON pc.category_id = p.category_id
            ),
            order_amount AS (
              SELECT
                o.product_id AS product_id,
                SUM(o.quantity * p.price) AS total_amount
              FROM ORDERS as o
              JOIN PRODUCTS as p ON o.product_id = p.product_id
              WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
              GROUP BY o.product_id
            ),
            rnk AS (
              SELECT
                pr.cat_name,
                pr.product_name,
                oa.total_amount,
                ROW_NUMBER() OVER (PARTITION BY pr.cat_name ORDER BY oa.total_amount DESC) AS rnk
              FROM order_amount as oa
              JOIN product as pr ON oa.product_id = pr.product_id
            )
            SELECT
              cat_name,
              product_name,
              total_amount
            FROM rnk
            WHERE rnk IN (1,2,3);")

ggplot(query_3, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))

```

4. Average delivery time for orders across the 5 slowest delivery suppliers

This code acts as a tool to analyse the efficiency of the shipping process. It focuses specifically on shipments marked as "delivered", linking them back to the suppliers who provided the products, relevant order details, and the shipment information itself. The code then calculates the average time it takes each supplier's products to be delivered from the moment they're dispatched to when they reach the customer. Finally, it ranks the suppliers based on their average delivery times, highlighting the top 5 suppliers with the slowest deliveries. This helps to identify potential areas for improvement within your supply chain.

The chart arranges the suppliers so the one with the longest average delivery time is at the top. This helps to instantly pinpoint the suppliers who might be slowing down the shipping process.

```{r}

# Define the SQL query for average delivery time for orders across top 5 delivery suppliers
query_4 <- dbGetQuery(my_connection,
           "SELECT 
               sup.supplier_id,
               sup.supplier_name AS supplier_name,
               AVG(julianday(s.delivered_timestamp) - julianday(s.dispatch_timestamp)) AS delivery_time
           FROM SHIPMENT AS s
           JOIN ORDERS AS o ON o.shipment_id = s.shipment_id
           JOIN PRODUCTS AS p ON p.product_id = o.product_id
           JOIN SUPPLIERS AS sup ON sup.supplier_id = p.supplier_id  -- Adjusted this line
           WHERE LOWER(s.status) = 'delivered'
           GROUP BY sup.supplier_id, sup.supplier_name
           ORDER BY delivery_time DESC, supplier_name
           LIMIT 5;")

ggplot(query_4, aes(x = reorder(supplier_name, delivery_time), y = delivery_time, fill = supplier_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Average Delivery Time for Top 5 Delivery Suppliers",
       x = "Supplier Name",
       y = "Average Delivery Time (Days)") +
  theme_minimal() +
  theme(legend.position = "none")

```

5. Top 20 Customers based on Average Spending 

This chunks helps to find out who the biggest spenders are. It starts by gathering customer information, their order details, and the products they've purchased (focusing on shipped or delivered orders). Then, it calculates both the average amount each customer spends per order and their total spending. Finally, it ranks the customers based on their average spending and displays the top 20.

The graph arranges top 20 customers with the highest average spending on top, making it super simple to spot the most valuable customers at a glance.

```{r}

# Define the SQL query
query_5 <- dbGetQuery(my_connection,
           "SELECT
              o.customer_id as customer_id,
              c.first_name ||' '|| c.last_name as customer_name,
              AVG(p.price*o.quantity) as avg_amount,
              SUM(p.price*o.quantity) as total_amount
            FROM ORDERS as o
            JOIN CUSTOMERS as c ON o.customer_id = c.customer_id
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
            GROUP BY o.customer_id,customer_name
            ORDER BY avg_amount DESC
            limit 20
           ;")

ggplot(query_5, aes(x = reorder(customer_name, avg_amount), y = avg_amount, fill = customer_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Average Spending Across Customers",
       x = "Customer",
       y = "Average Spending") +
  theme_minimal() +
  theme(axis.title.x = element_text(face = "bold"),
        axis.title.y = element_text(face = "bold"),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        legend.position = "none")
```

Among the top 20 customers, Gabi Boate is significantly leading, with average spending over £2000 indicating high-value transactions or frequent purchases. This suggests a potential segment of premium customers who contribute substantially to sales revenue.  

6. Top 5 Categories with the Most Cancellations

This code investigates cancelled orders. It aims to figure out which product categories have the most cancellations. To do this, it pulls information about cancelled orders, the specific products in those orders, and the categories those products belong to. Then, it counts the number of cancelled orders within each product category. Finally, it sorts the categories by the number of cancellations (highest to lowest), revealing the top 5 categories where customers are most likely to change their minds.

The chart rearranges the categories so those with the most cancellations are at the top. This lets you easily see which product categories are experiencing the highest levels of customer cancellations, helping to pinpoint potential problem areas.

```{r}

query_6 <- dbGetQuery(my_connection,
           "SELECT
              cat_name,
              COUNT(o.quantity) as total_cancelled
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) = 'cancelled'
            GROUP BY cat_name
            ORDER BY total_cancelled DESC
           ;")

ggplot(query_6, aes(x = reorder(cat_name, total_cancelled), y = total_cancelled, fill = cat_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Cancelled Orders by Category",
       x = "Category Name",
       y = "Number of Cancelled Orders") +
  theme_minimal() +
  theme(legend.position = "none")
```

The bar plot reveals that the toy category has the highest number of cancelled orders, followed closely by the beauty category. This underscores the importance for the business to closely monitor these categories and investigate the reasons for cancellations, whether they were initiated from the buyer’s side or seller’s side, before proceeding with any further actions. 
 
7. Average number of orders across time

```{r}

query_7 <- dbGetQuery(my_connection,
           "SELECT
              order_timestamp as date,
              SUM(o.quantity) as total_order
            FROM ORDERS as o
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY order_timestamp
            ORDER BY date
           ;")

ggplot(query_7,aes(x=date,y=total_order,group=1))+geom_point(stat="identity")+geom_line(stat="identity")+labs(x="Date",y="Total Number of Order")+theme(axis.text.x=element_text(angle=35))

```

The average number of orders fluctuates significantly over time with no consistent overall trend. Peaks reach an average of 4 orders per day, while lows drop below 2 orders per day. 

8. Scatter plot for revenue across quantity; color by category

```{r}

revenue_quantity <- dbGetQuery(my_connection,
           "SELECT
              cat_name,
              SUM(o.quantity) as quantity,
              SUM(p.price * o.quantity) as amount
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY cat_name
           ;")

ggplot(revenue_quantity, aes(x = quantity, y = amount, color = cat_name)) +
  geom_point(size=3) +
  theme_minimal() +
  labs(title = "Scatter Plot of Quantity vs Amount by Category",
       x = "Quantity",
       y = "Amount") +
  theme(legend.position = "right")

```

The scatter plot indicates varied sales across categories. High-value item likes Computers show substantial sales amounts, while Outdoors products suggest high revenue with lower quantities sold. Category like Beauty exhibits highest quantities, indicating most frequent purchases of items.

