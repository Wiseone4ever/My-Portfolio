---
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r}
library(readr)
library(RSQLite)
library(tibble) 
library(dplyr) 
library(lubridate)
library(DBI)
library(assertthat)
library(purrr)
library(ggplot2)
library(RSQLite)
library(DBI)
```


Part 1.2 - SQL Database Schema Creation 


```{r}

setwd("/cloud/project/")

#connect to the SQLite database
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")


dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS CUSTOMERS
                (   
                    customer_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    first_name VARCHAR(255) NOT NULL,
                    last_name VARCHAR(255),
                    username VARCHAR(255),
                    gender TEXT,
                    date_of_birth DATE NOT NULL,
                    email VARCHAR(255) UNIQUE,
                    phone VARCHAR(20) UNIQUE,
                    street_name VARCHAR(255),
                    city VARCHAR(255),
                    country VARCHAR(255),
                    zip_code VARCHAR(20),
                    account_created_date TIMESTAMP,
                    premium_subscription INTEGER
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCT_CATEGORY
                (
                    category_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    cat_name VARCHAR(255)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SUPPLIERS
                (
                    supplier_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    supplier_name VARCHAR(255),
                    supplier_address VARCHAR(500),
                    supplier_phone VARCHAR(20),
                    supplier_email VARCHAR(255) UNIQUE
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS PRODUCTS
                (
                    product_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    product_name VARCHAR(255),
                    price REAL,
                    stock_quantity INTEGER NOT NULL,
                    category_id VARCHAR(255) NOT NULL,
                    supplier_id VARCHAR(255) NOT NULL,
                    FOREIGN KEY(category_id) REFERENCES PRODUCT_CATEGORY(category_id),
                    FOREIGN KEY(supplier_id) REFERENCES SUPPLIERS(supplier_id)
                );"
          )

dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS GIFT_CARD
                (
                gift_card_id VARCHAR(50) NOT NULL PRIMARY KEY,
                gift_card_code VARCHAR(50),
                detail INTEGER,
                status VARCHAR(50)
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS ORDERS
                (
                    order_id VARCHAR(255) NOT NULL PRIMARY KEY,
                    customer_id VARCHAR(255),
                    product_id VARCHAR(255),
                    gift_card_id VARCHAR(255), 
                    payment_method TEXT,
                    quantity INTEGER,
                    order_timestamp TIMESTAMP,
                    payment_timestamp TIMESTAMP,
                    order_status VARCHAR(50) NOT NULL,
                    shipment_id VARCHAR(255),
                    FOREIGN KEY(customer_id) REFERENCES CUSTOMERS(customer_id),
                    FOREIGN KEY(product_id) REFERENCES PRODUCTS(product_id),
                    FOREIGN KEY(shipment_id) REFERENCES SHIPMENT(shipment_id), 
                    FOREIGN KEY(gift_card_id) REFERENCES GIFT_CARD(gift_card_id) 
                );"
          )
dbExecute(my_connection, 
                "CREATE TABLE IF NOT EXISTS SHIPMENT
                (
                shipment_id VARCHAR(255) NOT NULL PRIMARY KEY,
                dispatch_timestamp DATETIME,
                delivered_timestamp DATETIME,
                status VARCHAR(50) NOT NULL
                );"
          )

#Check if the tables are created

dbGetQuery(my_connection, 
    sprintf("SELECT name FROM sqlite_master WHERE type='table';")
  )


# dbDisconnect(my_connection)


```

#Generate Data

```{r}
## Find all files matching the pattern
customer_files <- list.files(path = "datasets",pattern = "CUSTOMERS.*\\.csv$",full.names = TRUE )
category_files <- list.files(path = "datasets",pattern = "CATEGORY.*\\.csv$",full.names = TRUE )
gift_card_files <- list.files(path = "datasets",pattern = "GIFT_CARDS.*\\.csv$",full.names = TRUE )
suppliers_files <- list.files(path = "datasets",pattern = "SUPPLIERS.*\\.csv$",full.names = TRUE )
products_files <- list.files(path = "datasets",pattern = "PRODUCTS.*\\.csv$",full.names = TRUE )

customers_df <- readr::read_csv(customer_files[1])
gift_card_df <- readr::read_csv(gift_card_files[1])
suppliers_df <- readr::read_csv(suppliers_files[1])
category_df <- readr::read_csv(category_files[1]) 
products_df <- readr::read_csv(products_files[1])



#Sample Customers

sample_size <- floor(0.2 * nrow(products_df))
sampled_product_ids <- sample(products_df$product_id, size = sample_size, replace = FALSE)
sampled_products_df <- products_df[products_df$product_id %in% sampled_product_ids, ]


#Sample Products

sample_size <- floor(0.2 * nrow(customers_df))
sampled_customer_ids <- sample(customers_df$customer_id, size = sample_size, replace = FALSE)
sampled_customers_df <- customers_df[customers_df$customer_id %in% sampled_customer_ids, ]


generate_orders_data <- function(n = 1000) {
  set.seed(123) 
  
  orders_df <- tibble(
    order_id = sprintf("%s-%04d", "ORD", 1:n),
    customer_id = sample(sampled_customers_df$customer_id, n, replace = TRUE),
    product_id = sample(sampled_products_df$product_id, n, replace = TRUE),
    gift_card_id = sample(c(NA, gift_card_df$gift_card_id), n, replace = TRUE), # Assuming gift cards are used as discounts
    payment_method = sample(c("Credit Card", "Debit Card", "PayPal", "Gift Card"), n, replace = TRUE),
    quantity = sample(1:5, n, replace = TRUE),
    order_timestamp = sample(seq(as.POSIXct('2024/02/01'), as.POSIXct('2024/02/29'), by="day"), n, replace = TRUE),
    payment_timestamp = order_timestamp + hours(sample(1:72, n, replace = TRUE)), # Payment within 1 to 72 hours after order
    order_status = sample(c("Processing", "Shipped", "Delivered", "Cancelled","Pending Payment","Out for Delivery"), n, replace = TRUE),
    #amount = round(runif(n, 50, 500), 2) # Random amount between $50 and $500
  )
  
  # Augment the orders data frame with supplier_id using left_join
  orders_df <- orders_df %>%
    left_join(sampled_products_df %>% select(product_id, supplier_id), by = "product_id") %>%
    select(order_id, customer_id, product_id, gift_card_id, payment_method, quantity, order_timestamp, payment_timestamp, order_status, supplier_id)
  
  return(orders_df)
}

# Generate orders data
orders_df <- generate_orders_data(n = 1000)

generate_shipment_ids <- function(df) {
  # Create a unique identifier for each group
  df <- df %>% 
    mutate(date_only = as.Date(order_timestamp)) %>% 
    group_by(customer_id, supplier_id, date_only) %>%
    mutate(shipment_group_id = cur_group_id()) %>%
    ungroup() %>%
    mutate(shipment_id = sprintf("SHIP%05d", shipment_group_id)) %>%
    select(-shipment_group_id, -date_only) # Clean up the extra columns
  
  df
}

# Apply the function to your data frame
orders_df <- generate_shipment_ids(orders_df)

# Optional: Adjusting for logical consistency (e.g., cancelled orders should not have a shipment_id)
  orders_df <- orders_df %>%
    mutate(shipment_id = if_else(order_status %in% c("Cancelled","Pending Payment"), NA_character_,
                                 as.character(shipment_id)),
           payment_method = if_else(order_status == "Pending Payment",NA_character_,payment_method)) %>%
    mutate(supplier_id = NULL)
```


```{r}
#Shipment Table
  
  shipment_df <- orders_df %>%
    mutate(
      # Dispatch date could be the same as the order date or a day after
      dispatch_timestamp = order_timestamp + days(sample(0:1, n(), replace = TRUE)),
      
      # Delivered date should be after the dispatch date; here I assume delivery takes between 2 to 5 days
      delivered_timestamp = dispatch_timestamp + days(sample(2:5, n(), replace = TRUE)),
      
      # Randomly assign a delivery status
      status = if_else(order_status == "Processing","Ready for Dispatch",if_else(order_status == "Shipped","In Transit",if_else(order_status == "Out for Delivery",order_status,if_else(order_status == "Delivered",order_status,"NA"))))
    ) %>%
    # Select only the relevant columns for the shipment table
    select(shipment_id, dispatch_timestamp, delivered_timestamp, status) %>%
    # Remove duplicate rows to ensure unique shipments
    distinct() 

  shipment_df <- na.omit(shipment_df)
  
  
  shipment_df <- shipment_df %>%
    mutate(
      # Assign NA to dispatch_timestamp if status is 'Ready for Dispatch'
      dispatch_timestamp = if_else(status == "Ready for Dispatch", NA_Date_, dispatch_timestamp),
      delivered_timestamp = if_else(status == "Ready for Dispatch", NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "In Transit", Sys.Date() - days(sample(1:5, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "In Transit", NA_Date_, delivered_timestamp),
      
      # 'In Transit' status should have a dispatch date but no delivery date
      dispatch_timestamp = if_else(status == "Out for Delivery", Sys.Date() - days(sample(1:5, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "Out for Delivery", NA_Date_, delivered_timestamp),
      
      # If status is 'Delivered', both dates should be in the past, with delivered after dispatched
      dispatch_timestamp = if_else(status == "Delivered" & is.na(dispatch_timestamp), Sys.Date() - days(sample(6:10, 1)), dispatch_timestamp),
      delivered_timestamp = if_else(status == "Delivered", dispatch_timestamp + days(sample(1:5, 1)), delivered_timestamp)
    )
  
write_csv(orders_df,"datasets/ORDERS.csv")

write_csv(shipment_df,"datasets/SHIPMENTS.csv")


```

Data Validation and Ingestion

1.CUSTOMERS

```{r}
ingest_customer_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  # Data validation

  #email check
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", df$email)
  df <- df[valid_email, ]
  
  #gender check
  valid_genders <- c("Male", "Female", "Other")
  df <- df[df$gender %in% valid_genders, ]
  

  # Data type checks (adjust according to your data frame)
  df$date_of_birth <- as.Date(df$date_of_birth,format = "%d/%m/%y")
  df$account_created_date <- as.Date(df$account_created_date,format = "%d/%m/%y")
  df$premium_subscription <- as.integer(df$premium_subscription)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("customer_id", "first_name", "date_of_birth")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    
      #Check for duplicate records based on the primary key
   existing_ids <- dbGetQuery(my_connection, sprintf("SELECT customer_id FROM CUSTOMERS WHERE customer_id = '%s'",   df$customer_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for customer_id: %s\n", df$customer_id[i]))
      next
    }
     
    insert_query <- sprintf("INSERT INTO CUSTOMERS (customer_id, first_name, last_name, username, gender, date_of_birth, email, phone, street_name, city, country, zip_code, account_created_date, premium_subscription)
                            VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', %d)",
                            df$customer_id[i], df$first_name[i], df$last_name[i], df$username[i], df$gender[i], df$date_of_birth[i],
                            df$email[i], df$phone[i], df$street_name[i], df$city[i], df$country[i], df$zip_code[i], df$account_created_date[i], df$premium_subscription[i])
    tryCatch({
dbExecute(my_connection, insert_query)
  cat(sprintf("Successfully inserted row: %d\n", i))
}, error = function(e) {
  cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
})
  }

  # Close the database connection
  dbDisconnect(my_connection)
}

for(file in customer_files) {
  df <- readr::read_csv(file)
  ingest_customer_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM CUSTOMERS;")
```


2. PRODUCT_CATEGORY 

```{r}
ingest_product_category <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Check for null values in NOT NULL columns
  required_columns <- c("category_id", "cat_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT category_id FROM PRODUCT_CATEGORY WHERE category_id = '%s'", df$category_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for category_id: %s\n", df$category_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO PRODUCT_CATEGORY (category_id, cat_name) VALUES ('%s', '%s')",
                            df$category_id[i], df$cat_name[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
  
    dbDisconnect(my_connection)

}

for(file in category_files) {
  
  df <- readr::read_csv(file)
  ingest_product_category(df)
}

```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCT_CATEGORY;")
```


SUPPLIERS

```{r}
ingest_suppliers <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Email format validation
  valid_email <- grepl("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", df$supplier_email)
  df <- df[valid_email, ]
  
  # Check for null values in NOT NULL columns
  required_columns <- c("supplier_id", "supplier_name")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_supplier_ids <- dbGetQuery(my_connection, sprintf("SELECT supplier_id FROM SUPPLIERS WHERE supplier_id = '%s'", df$supplier_id[i]))
    if(nrow(existing_supplier_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for supplier_id: %s\n", df$supplier_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SUPPLIERS (supplier_id, supplier_name, supplier_address, supplier_phone, supplier_email) VALUES ('%s', '%s', '%s', '%s', '%s')",
                            df$supplier_id[i], df$supplier_name[i], df$supplier_address[i], df$supplier_phone[i], df$supplier_email[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
    
  }
    dbDisconnect(my_connection)

}

for(file in suppliers_files) {
  
  df <- readr::read_csv(file)
  ingest_suppliers(df)
  
}

```

GIFT CARDS

```{r}

ingest_gift_card_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Validate 'gift_card_id' and 'gift_card_code' for null values
  required_columns <- c("gift_card_id", "gift_card_code", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Ensure 'detail' is an integer
  df$detail <- as.numeric(df$detail)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT gift_card_id FROM GIFT_CARD WHERE gift_card_id = '%s'", df$gift_card_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for gift_card_id: %s\n", df$gift_card_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO GIFT_CARD (gift_card_id, gift_card_code, detail, status) VALUES ('%s', '%s', %f, '%s')",
                            df$gift_card_id[i], df$gift_card_code[i], df$detail[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in gift_card_files) {
  
  df <- readr::read_csv(file)
  ingest_gift_card_data(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM GIFT_CARD;")
```

PRODUCTS

```{r}
ingest_products <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  # Data type checks
  df$stock_quantity <- as.integer(df$stock_quantity)
  
  # Check for null values in NOT NULL columns
  required_columns <- c("product_id", "stock_quantity", "category_id", "supplier_id")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key and foreign key constraints
    existing_product_ids <- dbGetQuery(my_connection, sprintf("SELECT product_id FROM PRODUCTS WHERE product_id = '%s'", df$product_id[i]))
    if(nrow(existing_product_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for product_id: %s\n", df$product_id[i]))
      next
    }
    
    # Construct and execute the insertion query
    insert_query <- sprintf("INSERT INTO PRODUCTS (product_id, product_name, price, stock_quantity, category_id, supplier_id) VALUES ('%s', '%s', %f, %d, '%s', '%s')",
                            df$product_id[i], df$product_name[i], df$price[i], df$stock_quantity[i], df$category_id[i], df$supplier_id[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

for(file in products_files) {
  
  df <- readr::read_csv(file)
  ingest_products(df)
  
}

```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM PRODUCTS;")
```


ORDER

```{r}
ingest_orders <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")

  # Essential columns for validation
  required_columns <- c("order_id", "order_status", "quantity")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  for(i in 1:nrow(df)) {
    # Check for duplicate order_id
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT order_id FROM ORDERS WHERE order_id = '%s'", df$order_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for order_id: %s\n", df$order_id[i]))
      next
    }

    # Data validation for quantity
    if(!is.numeric(df$quantity[i]) || df$quantity[i] <= 0) {
      cat(sprintf("Skipping entry due to invalid quantity for order_id: %s\n", df$order_id[i]))
      next
    }

    # Insert validated data into the database
    insert_query <- sprintf("INSERT INTO ORDERS (order_id, customer_id, product_id, shipment_id, gift_card_id, payment_method, quantity, order_timestamp, payment_timestamp, order_status) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', %d, '%s', '%s', '%s')",
                            df$order_id[i], df$customer_id[i], df$product_id[i], df$shipment_id[i], df$gift_card_id[i], df$payment_method[i], df$quantity[i], df$order_timestamp[i], df$payment_timestamp[i], df$order_status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}


# Assume orders_df is your DataFrame containing orders data
ingest_orders(orders_df)


```


```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM ORDERS;")
```


SHIPMENTS

```{r}
ingest_shipment_data <- function(df) {
  
  my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
  # Validate 'shipment_id' and 'status' for null values
  required_columns <- c("shipment_id", "status")
  df <- df[!rowSums(is.na(df[required_columns])) > 0, ]
  
  # Convert timestamps to appropriate format
 #df$dispatch_timestamp <- ifelse(is.na(df$dispatch_timestamp), "", df$dispatch_timestamp)
  #df$delivered_timestamp <- ifelse(is.na(df$delivered_timestamp), "", df$delivered_timestamp)
  
  # Insert validated data into the database
  for(i in 1:nrow(df)){
    # Check for duplicate records based on the primary key
    existing_ids <- dbGetQuery(my_connection, sprintf("SELECT shipment_id FROM SHIPMENT WHERE shipment_id = '%s'", df$shipment_id[i]))
    if(nrow(existing_ids) > 0) {
      cat(sprintf("Skipping duplicate entry for shipment_id: %s\n", df$shipment_id[i]))
      next
    }
    
    insert_query <- sprintf("INSERT INTO SHIPMENT (shipment_id, dispatch_timestamp, delivered_timestamp, status) VALUES ('%s', '%s', '%s', '%s')",
                            df$shipment_id[i], df$dispatch_timestamp[i], df$delivered_timestamp[i], df$status[i])
    tryCatch({
      dbExecute(my_connection, insert_query)
      cat(sprintf("Successfully inserted row: %d\n", i))
    }, error = function(e) {
      cat(sprintf("Error in inserting row: %d, Error: %s\n", i, e$message))
    })
  }
    dbDisconnect(my_connection)

}

ingest_shipment_data(shipment_df)
```

```{r}
my_connection <- RSQLite::dbConnect(RSQLite::SQLite(), "database/ecommerce_database_v1.db")
dbGetQuery(my_connection,"SELECT * FROM SHIPMENT;")
```

1. Top 10 Products - Overall (Quantity)
2. Top 5 Categories (Quantity)
3. Top 3 Products across categories (Total Amount)
```{r}
# Join orders with products to get category information
orders_with_category <- orders_df %>%
  inner_join(products_df, by = "product_id")

# Calculate total amount for each product
product_amounts <- orders_with_category %>%
  group_by(category_id, product_id, product_name) %>%
  summarise(total_amount = sum(quantity * price, na.rm = TRUE)) %>%
  ungroup()

# Join with category_df to get category names
product_amounts_with_category_name <- product_amounts %>%
  inner_join(category_df, by = "category_id")

# Get overall top 3 products
top_3_products <- product_amounts_with_category_name %>%
  arrange(desc(total_amount)) %>%
  slice_max(total_amount, n = 3) %>%
  ungroup()

# Plot using ggplot2
ggplot(top_3_products, aes(x = reorder(product_name, total_amount), y = total_amount, fill = cat_name)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip() +
  labs(title = "Top 3 Products by Total Amount",
       x = "Product Name",
       y = "Total Amount") +
  theme_minimal() +
  theme(legend.title = element_text(size = 12),
        legend.text = element_text(size = 10))
```

<<<<<<< HEAD

=======
4. Average delivery time for orders across top 5 delivery suppliers
>>>>>>> d065673478773d9575d62ba440477f02d2d07c48

5. Top 20 Average Spending across customers
6. Top 20 cancelled orders for which category
```{r}
# Join orders with products and then with categories to get category information
orders_with_categories <- orders_df %>%
  inner_join(products_df, by = "product_id") %>%
  inner_join(category_df, by = "category_id")

# Filter for cancelled orders and count by category
cancelled_orders_by_category <- orders_with_categories %>%
  filter(order_status == "Cancelled") %>%
  count(cat_name) %>%
  arrange(desc(n)) %>%
  top_n(20, n)

# Visualization
ggplot(cancelled_orders_by_category, aes(x = reorder(cat_name, n), y = n, fill = cat_name)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(title = "Top 20 Cancelled Orders by Category",
       x = "Category Name",
       y = "Number of Cancelled Orders") +
  theme_minimal() +
  theme(legend.position = "none")
```

7. Average number of orders across time
8. Scatter plot for revenue across quantity; color by category

Foreign Key Check
ORDERS
customer_id check
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.customer_id as customer_id,
              c.customer_id as customer_id,
              first_name ||' '|| last_name as customer_name
           FROM ORDERS as o
           LEFT JOIN CUSTOMERS as c ON c.customer_id = o.customer_id
           ;")
```

product_id check
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.product_id as product_id,
              p.product_id as product_id,
              product_name as product_name
           FROM ORDERS as o
           LEFT JOIN PRODUCTS as p ON o.product_id = p.product_id
           ;")
```

gift_card_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.gift_card_id as gif_card_id,
              g.gift_card_id,
              gift_card_code
           FROM ORDERS as o
           LEFT JOIN GIFT_CARD as g ON g.gift_card_id = o.gift_card_id
           ;")
```

shipment_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT o.shipment_id as x,
              s.shipment_id
           FROM ORDERS as o
           LEFT JOIN SHIPMENT as s ON s.shipment_id = o.shipment_id
           ORDER BY o.shipment_id
           ;")
```

PRODUCTS
supplier_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.supplier_id,
              s.supplier_id as a,
              s.supplier_name
           FROM PRODUCTS as p
           LEFT JOIN SUPPLIERS as s ON p.supplier_id = s.supplier_id
           ORDER BY p.supplier_id
           ;")
```

category_id
```{r}
dbGetQuery(my_connection,
           "SELECT 
              DISTINCT p.category_id,
              c.category_id as c,
              cat_name
           FROM PRODUCTS as p
           LEFT JOIN PRODUCT_CATEGORY as c ON c.category_id = p.category_id
           ORDER BY p.category_id
           ;")
```


SQL version
1. Top 10 Products - Overall (Quantity)
```{r}

dbGetQuery(my_connection,
           "SELECT 
              ORDERS.product_id,
              product_name,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY ORDERS.product_id,product_name
           ORDER BY total_purchase desc
           LIMIT 10
           ;")
```

2. Top 5 Categories (Quantity)
```{r}

dbGetQuery(my_connection,
           "SELECT 
              cat_name as category,
              count(quantity) as total_purchase
           FROM ORDERS
           JOIN PRODUCTS ON ORDERS.product_id = PRODUCTS.product_id
           JOIN PRODUCT_CATEGORY ON PRODUCTS.category_id = PRODUCT_CATEGORY.category_id
           WHERE lower(order_status) in ('shipped','delivered')
           GROUP BY cat_name
           ORDER by total_purchase desc
           LIMIT 5
           ;")
```

3. Top 3 Products across categories (Total Amount)
```{r}

dbGetQuery(my_connection,
           "WITH product AS (
              SELECT
                p.product_id,
                pc.cat_name,
                p.product_name
              FROM PRODUCTS as p
              JOIN PRODUCT_CATEGORY as pc ON pc.category_id = p.category_id
            ),
            order_amount AS (
              SELECT
                o.product_id AS product_id,
                SUM(o.quantity * p.price) AS total_amount
              FROM ORDERS as o
              JOIN PRODUCTS as p ON o.product_id = p.product_id
              WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
              GROUP BY o.product_id
            ),
            rnk AS (
              SELECT
                pr.cat_name,
                pr.product_name,
                oa.total_amount,
                ROW_NUMBER() OVER (PARTITION BY pr.cat_name ORDER BY oa.total_amount DESC) AS rnk
              FROM order_amount as oa
              JOIN product as pr ON oa.product_id = pr.product_id
            )
            SELECT
              cat_name,
              product_name,
              total_amount
            FROM rnk
            WHERE rnk IN (1,2,3);")

```

4. Average delivery time for orders across top 5 delivery suppliers
```{r}

dbGetQuery(my_connection,
           "SELECT 
               sup.supplier_id,
               sup.supplier_name AS supplier_name,
               AVG(julianday(s.delivered_timestamp) - julianday(s.dispatch_timestamp)) AS delivery_time
           FROM SHIPMENT AS s
           JOIN ORDERS AS o ON o.shipment_id = s.shipment_id
           JOIN PRODUCTS AS p ON p.product_id = o.product_id
           JOIN SUPPLIERS AS sup ON sup.supplier_id = p.supplier_id  -- Adjusted this line
           WHERE LOWER(s.status) = 'delivered'
           GROUP BY sup.supplier_id, sup.supplier_name
           ORDER BY delivery_time DESC, supplier_name
           LIMIT 5;")

```

5. Top 20 Average Spending across customers
```{r}

dbGetQuery(my_connection,
           "SELECT
              o.customer_id as customer_id,
              c.first_name ||' '|| c.last_name as customer_name,
              AVG(p.price*o.quantity) as avg_amount,
              SUM(p.price*o.quantity) as total_amount
            FROM ORDERS as o
            JOIN CUSTOMERS as c ON o.customer_id = c.customer_id
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            WHERE LOWER(o.order_status) IN ('shipped', 'delivered')
            GROUP BY o.customer_id,customer_name
            ORDER BY avg_amount DESC
            limit 20
           ;")

```

6. Top 20 cancelled orders for which category
```{r}

dbGetQuery(my_connection,
           "SELECT
              cat_name,
              COUNT(o.quantity) as total_cancelled
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) = 'cancelled'
            GROUP BY cat_name
            ORDER BY total_cancelled DESC
           ;")

```

7. Average number of orders across time
```{r}

dbGetQuery(my_connection,
           "SELECT
              order_timestamp as date,
              SUM(o.quantity) as total_order
            FROM ORDERS as o
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY order_timestamp
            ORDER BY date
           ;")

```

8. Scatter plot for revenue across quantity; color by category
```{r}

revenue_quantity <- dbGetQuery(my_connection,
           "SELECT
              cat_name,
              SUM(o.quantity) as quantity,
              SUM(p.price * o.quantity) as amount
            FROM ORDERS as o
            JOIN PRODUCTS as p ON p.product_id = o.product_id
            JOIN PRODUCT_CATEGORY as pc on pc.category_id = p.category_id
            WHERE LOWER(order_status) IN ('shipped', 'delivered')
            GROUP BY cat_name
           ;")

ggplot(revenue_quantity, aes(x = quantity, y = amount, color = cat_name)) +
  geom_point() +
  theme_minimal() +
  labs(title = "Scatter Plot of Quantity vs Amount by Category",
       x = "Quantity",
       y = "Amount") +
  theme(legend.position = "right")

```



